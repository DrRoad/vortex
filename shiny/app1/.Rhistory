variable_choices
vars <- read.csv("data/variable_names", stringsAsFactors=F)
vars
vars <- read.csv("data/variable_names", stringsAsFactors=F)
vars <- read.csv("data/variable_names", stringsAsFactors=F) %>%
filter(category != "other") %>%
arrange(desc(category), display)
r2d <- function(x) vars$display[match(x, vars$raw)]
d2r <- function(x) vars$raw[match(x, vars$display)]
runApp()
runApp()
vars$display[vars$category=="social"][1]
vars$display[vars$category=="risk"][1]
input <- list(xv=vars$display[vars$category=="social"][1],
yv=vars$display[vars$category=="risk"][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
d <- data.frame(fips=e$fips,
#state_fips=e$state_fips,
#county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,d2r(input$xv)],
y=e[,d2r(input$yv)]) %>%
mutate(xlog=log10(x), ylog=log10(y))
head(d)
if(input$region != "USA") d <- filter(d, state %in% input$region)
# approximate log-destroyed values
d$xlog[d$xlog==-Inf] <- min(d$xlog[is.finite(d$xlog)])
d$ylog[d$ylog==-Inf] <- min(d$ylog[is.finite(d$ylog)])
# get 2D color values
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog"),
switch(input$yscale, "linear"="y", "log10"="ylog"))
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
palette <- switch(input$palette,
inferno=c("yellow", "red", "black", "blue", "white"),
dayglo=c("yellow", "green", "dodgerblue", "magenta", "white"),
alfalfa=c("darkgreen", "dodgerblue", "gray95", "yellow", "white"),
proton=c("cyan", "black", "gray95", "magenta", "white"))
if(input$transpose_palette) palette[c(2,4)] <- palette[c(4,2)]
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]), palette[1:4])
d$color[is.na(d$color)] <- palette[5]
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
runApp()
input <- list(xv=vars$display[vars$category=="social"][1],
yv=vars$display[vars$category=="risk"][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
palette="inferno",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
library(devtools)
library(maps)
library(mapproj)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
if(!require(colormap)) install_github("matthewkling/colormap", "colormap") # Add the package colormap that Matt created because he's a bamf.
select <- dplyr::select
# load data
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips, -land_area)
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-CTYNAME, -state_fips, -county_fips)
# fips-to-name dictionary from maps library;
FIPS <- maps::county.fips
FIPS$polyname <- as.character(FIPS$polyname)
FIPS$polyname[FIPS$polyname=="florida,miami-dade"] <- "florida,dade"
# a clean counties table with the proper number and order of counties for plotting
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS) %>%
mutate(ID=1:n())
#if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips))
fill <- function(x) na.omit(x)[1]
e <- left_join(cty, e) %>%
group_by(ID) %>%
summarise_each(funs(fill)) %>%
ungroup() %>%
filter(!duplicated(ID))
#if(!all.equal(cty$fips, e$fips)) stop("incorrect county structure")
e <- as.data.frame(e)
# fill in some missing values -- this is a patch that shold be transferred to the data prep scripts
na2min <- function(x){
x[is.na(x) | x<0] <- min(na.omit(x[x>=0]))
return(x)
}
e <- mutate_each_(e, funs(na2min), names(e)[grepl("tot_intensity", names(e))])
vars <- read.csv("data/variable_names", stringsAsFactors=F) %>%
filter(category != "other") %>%
arrange(desc(category), display)
r2d <- function(x) vars$display[match(x, vars$raw)]
d2r <- function(x) vars$raw[match(x, vars$display)]
### test ###
#map("county", regions=".", fill = TRUE, col=rep("black", nrow(cty)),
#    resolution = 0, lty = 0, projection = "polyconic",
#    myborder = 0, mar = c(0,0,0,0))
#et <- read.csv("data/master_county_data.csv", stringsAsFactors=F) %>%
#      select(-land_area) %>%
#      mutate(state_fips=as.integer(state_fips),
#             county_fips=as.integer(county_fips)) %>%
#      mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
#      left_join(FIPS, .)
#map("county", regions=".", fill = TRUE, col=rep("black", length(na.omit(et$pop_total_2014...POP_ESTIMATE_2014))),
#    resolution = 0, lty = 0, projection = "polyconic",
#    myborder = 0, mar = c(0,0,0,0))
### end test ###
input <- list(xv=vars$display[vars$category=="social"][1],
yv=vars$display[vars$category=="risk"][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
palette="inferno",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
d <- data.frame(fips=e$fips,
#state_fips=e$state_fips,
#county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,d2r(input$xv)],
y=e[,d2r(input$yv)]) %>%
mutate(xlog=log10(x), ylog=log10(y))
str(d)
if(input$region != "USA") d <- filter(d, state %in% input$region)
d$xlog[d$xlog==-Inf] <- min(d$xlog[is.finite(d$xlog)])
d$ylog[d$ylog==-Inf] <- min(d$ylog[is.finite(d$ylog)])
str(d)
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog"),
switch(input$yscale, "linear"="y", "log10"="ylog"))
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
palette <- switch(input$palette,
inferno=c("yellow", "red", "black", "blue", "white"),
dayglo=c("yellow", "green", "dodgerblue", "magenta", "white"),
alfalfa=c("darkgreen", "dodgerblue", "gray95", "yellow", "white"),
proton=c("cyan", "black", "gray95", "magenta", "white"))
if(input$transpose_palette) palette[c(2,4)] <- palette[c(4,2)]
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]), palette[1:4])
d$color[is.na(d$color)] <- palette[5]
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
alpha <- switch(input$region, "USA"=.6, .8)
size <- switch(input$region, "USA"=6, 20)
p <- ggplot(d(), aes(x, y, alpha=pop)) +
geom_point(size = scales::rescale(log(d()$pop)) * size,
fill=d()$color, color=NA,
alpha=alpha, shape=21) +
theme_minimal() +
theme(text=element_text(size=20)) +
labs(x=paste0(input$xv, "\n(point size proportional to county population)"), y=input$yv)
p <- ggplot(d, aes(x, y, alpha=pop)) +
geom_point(size = scales::rescale(log(d$pop)) * size,
fill=d$color, color=NA,
alpha=alpha, shape=21) +
theme_minimal() +
theme(text=element_text(size=20)) +
labs(x=paste0(input$xv, "\n(point size proportional to county population)"), y=input$yv)
p
if(input$smoother %in% c("lm", "loess")) p <- p + geom_smooth(color="black", se=input$se, method=input$smoother)
if(input$smoother=="gam") p <- p + geom_smooth(color="black", se=input$se, method="gam", formula = y ~ s(x))
if(input$xscale=="log10") p <- p + scale_x_log10()
if(input$yscale=="log10") p <- p + scale_y_log10()
plot(p)
region <- tolower(input$region)
if(input$region=="USA") region <- "."
map("county", regions=region, fill=TRUE, col=d()$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
map("county", regions=region, fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
runApp()
library(devtools)
library(maps)
library(mapproj)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
if(!require(colormap)) install_github("matthewkling/colormap", "colormap") # Add the package colormap that Matt created because he's a bamf.
select <- dplyr::select
# load data
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips, -land_area)
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-CTYNAME, -state_fips, -county_fips)
# fips-to-name dictionary from maps library;
FIPS <- maps::county.fips
FIPS$polyname <- as.character(FIPS$polyname)
FIPS$polyname[FIPS$polyname=="florida,miami-dade"] <- "florida,dade"
# a clean counties table with the proper number and order of counties for plotting
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS) %>%
mutate(ID=1:n())
#if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips))
fill <- function(x) na.omit(x)[1]
e <- left_join(cty, e) %>%
group_by(ID) %>%
summarise_each(funs(fill)) %>%
ungroup() %>%
filter(!duplicated(ID))
#if(!all.equal(cty$fips, e$fips)) stop("incorrect county structure")
e <- as.data.frame(e)
# fill in some missing values -- this is a patch that shold be transferred to the data prep scripts
na2min <- function(x){
x[is.na(x) | x<0] <- min(na.omit(x[x>=0]))
return(x)
}
e <- mutate_each_(e, funs(na2min), names(e)[grepl("tot_intensity", names(e))])
vars <- read.csv("data/variable_names", stringsAsFactors=F) %>%
filter(category != "other") %>%
arrange(desc(category), display)
r2d <- function(x) vars$display[match(x, vars$raw)]
d2r <- function(x) vars$raw[match(x, vars$display)]
### test ###
#map("county", regions=".", fill = TRUE, col=rep("black", nrow(cty)),
#    resolution = 0, lty = 0, projection = "polyconic",
#    myborder = 0, mar = c(0,0,0,0))
#et <- read.csv("data/master_county_data.csv", stringsAsFactors=F) %>%
#      select(-land_area) %>%
#      mutate(state_fips=as.integer(state_fips),
#             county_fips=as.integer(county_fips)) %>%
#      mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
#      left_join(FIPS, .)
#map("county", regions=".", fill = TRUE, col=rep("black", length(na.omit(et$pop_total_2014...POP_ESTIMATE_2014))),
#    resolution = 0, lty = 0, projection = "polyconic",
#    myborder = 0, mar = c(0,0,0,0))
### end test ###
vars
g2r(input$groups)
g2r <- function(x) vars$raw[match(x, vars$group)]
g2r(input$groups)
choices=na.omit(vars$groups)
choices=na.omit(vars$group)
choices=na.omit(vars$group[vars$group!=""])
g2r(input$groups)
input <- list(xv=vars$display[vars$category=="social"][1],
yv=vars$display[vars$category=="risk"][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
palette="inferno",
groups=na.omit(vars$group[vars$group!=""])[1],
envvar=vars$display[vars$category=="risk"][1],
scale="linear",
histogram_region="USA")
g2r(input$groups)
runApp()
na.omit(vars$group[vars$group!=""])[1]
na.omit(vars$group[vars$group!=""])
vars$display[vars$category=="risk"]
vars$display[vars$category=="risk"][1]
s <- data.frame(e[,g2r(input$groups)])
s <- as.data.frame(as.matrix(s) * e$TOTPOP)
if(ncol(s)==1) names(s) <- g2r(input$groups)
v <- e[,d2r(input$envvar)]
runApp()
runApp()
regexpr("(", "asdfadf ()")
regexpr("(", "asdfadf ()")
regexpr("\(", "asdfadf ()")
regexpr("()", "asdfadf ()")
?regexpr
regexpr("(", "asdf")
regexpr("\\(", "asdf")
regexpr("\\(", "asdf ()")
regexpr("\\(", "asdf ()")[1]
beforeparens <- function(x) substr(x, 1, regexpr("\\(", x)[1]-1)
beforeparens("asdfasdf ()")
beforeparens <- function(x) substr(x, 1, regexpr("\\(", x)[1]-2)
beforeparens <- function(x) substr(x, 1, regexpr("\\(", x)[1]-2)
beforeparens("asdfasdf")
beforeparens <- function(x){
if(grepl("\\(", x)) return(substr(x, 1, regexpr("\\(", x)[1]-2))
return(x)}
beforeparens("asdfasdf")
beforeparens("asdfasdf()")
runApp()
input <- list(xv=vars$display[vars$category=="social"][1],
yv=vars$display[vars$category=="risk"][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
palette="inferno",
groups=na.omit(vars$group[vars$group!=""])[1],
envvar=vars$display[vars$category=="risk"][1],
scale="linear",
histogram_region="USA")
input$xscale="rank"
d <- data.frame(fips=e$fips,
#state_fips=e$state_fips,
#county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,d2r(input$xv)],
y=e[,d2r(input$yv)])
# subset to selected state
if(input$region != "USA") d <- filter(d, state %in% input$region)
d <- mutate(d,
xlog=log10(x), ylog=log10(y),
xrank=ecdf(x)(x), yrank=ecdf(y)(y))
d$xlog[d$xlog==-Inf] <- min(d$xlog[is.finite(d$xlog)])
d$ylog[d$ylog==-Inf] <- min(d$ylog[is.finite(d$ylog)])
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
palette <- switch(input$palette,
inferno=c("yellow", "red", "black", "blue", "white"),
dayglo=c("yellow", "green", "dodgerblue", "magenta", "white"),
alfalfa=c("darkgreen", "dodgerblue", "gray95", "yellow", "white"),
proton=c("cyan", "black", "gray95", "magenta", "white"))
if(input$transpose_palette) palette[c(2,4)] <- palette[c(4,2)]
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]), palette[1:4])
d$color[is.na(d$color)] <- palette[5]
palette
input$transpose_palette=F
palette <- switch(input$palette,
inferno=c("yellow", "red", "black", "blue", "white"),
dayglo=c("yellow", "green", "dodgerblue", "magenta", "white"),
alfalfa=c("darkgreen", "dodgerblue", "gray95", "yellow", "white"),
proton=c("cyan", "black", "gray95", "magenta", "white"))
if(input$transpose_palette) palette[c(2,4)] <- palette[c(4,2)]
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]), palette[1:4])
d$color[is.na(d$color)] <- palette[5]
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
alpha <- switch(input$region, "USA"=.6, .8)
size <- switch(input$region, "USA"=6, 20)
ggplot(d(), aes(x, y, alpha=pop)) +
geom_point(size = scales::rescale(log(d()$pop)) * size,
fill=d()$color, color=NA,
alpha=alpha, shape=21) +
theme_minimal() +
theme(text=element_text(size=20)) +
labs(x=paste0(input$xv, "\n(point size proportional to county population)"), y=input$yv)
ggplot(d, aes(x, y, alpha=pop)) +
geom_point(size = scales::rescale(log(d$pop)) * size,
fill=d$color, color=NA,
alpha=alpha, shape=21) +
theme_minimal() +
theme(text=element_text(size=20)) +
labs(x=paste0(input$xv, "\n(point size proportional to county population)"), y=input$yv)
input
runApp()
input
str(d)
hist(d$xrank)
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog", "rank"="xrank"),
switch(input$yscale, "linear"="y", "log10"="ylog", "rank"="yrank"))
colvars
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
palette <- switch(input$palette,
inferno=c("yellow", "red", "black", "blue", "white"),
dayglo=c("yellow", "green", "dodgerblue", "magenta", "white"),
alfalfa=c("darkgreen", "dodgerblue", "gray95", "yellow", "white"),
proton=c("cyan", "black", "gray95", "magenta", "white"))
if(input$transpose_palette) palette[c(2,4)] <- palette[c(4,2)]
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]), palette[1:4])
d$color[is.na(d$color)] <- palette[5]
runApp()
alpha <- switch(input$region, "USA"=.6, .8)
size <- switch(input$region, "USA"=6, 20)
if(input$xtrans=="rank") input$x <- input$xrank
runApp()
alpha <- switch(input$region, "USA"=.6, .8)
size <- switch(input$region, "USA"=6, 20)
#if(input$xtrans=="rank") d()$x <- d()$xrank
#if(input$ytrans=="rank") d()$y <- d()$yrank
p <- ggplot(d(), aes(x, y, alpha=pop)) +
geom_point(size = scales::rescale(log(d()$pop)) * size,
fill=d()$color, color=NA,
alpha=alpha, shape=21) +
theme_minimal() +
theme(text=element_text(size=20)) +
labs(x=paste0(input$xv, "\n(point size proportional to county population)"), y=input$yv)
alpha <- switch(input$region, "USA"=.6, .8)
size <- switch(input$region, "USA"=6, 20)
#if(input$xtrans=="rank") d()$x <- d()$xrank
#if(input$ytrans=="rank") d()$y <- d()$yrank
p <- ggplot(d, aes(x, y, alpha=pop)) +
geom_point(size = scales::rescale(log(d$pop)) * size,
fill=d()$color, color=NA,
alpha=alpha, shape=21) +
theme_minimal() +
theme(text=element_text(size=20)) +
labs(x=paste0(input$xv, "\n(point size proportional to county population)"), y=input$yv)
alpha <- switch(input$region, "USA"=.6, .8)
size <- switch(input$region, "USA"=6, 20)
#if(input$xtrans=="rank") d()$x <- d()$xrank
#if(input$ytrans=="rank") d()$y <- d()$yrank
p <- ggplot(d, aes(x, y, alpha=pop)) +
geom_point(size = scales::rescale(log(d$pop)) * size,
fill=d$color, color=NA,
alpha=alpha, shape=21) +
theme_minimal() +
theme(text=element_text(size=20)) +
labs(x=paste0(input$xv, "\n(point size proportional to county population)"), y=input$yv)
plot(p)
runApp()
str(d)
runApp()
input$xtrans
runApp()
str(e)
# load data
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips, -land_area)
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
#select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-CTYNAME, -state_fips, -county_fips)
# fips-to-name dictionary from maps library;
FIPS <- maps::county.fips
FIPS$polyname <- as.character(FIPS$polyname)
FIPS$polyname[FIPS$polyname=="florida,miami-dade"] <- "florida,dade"
# a clean counties table with the proper number and order of counties for plotting
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS) %>%
mutate(ID=1:n())
#if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips))
fill <- function(x) na.omit(x)[1]
e <- left_join(cty, e) %>%
group_by(ID) %>%
summarise_each(funs(fill)) %>%
ungroup() %>%
filter(!duplicated(ID))
#if(!all.equal(cty$fips, e$fips)) stop("incorrect county structure")
e <- as.data.frame(e)
# fill in some missing values -- this is a patch that shold be transferred to the data prep scripts
na2min <- function(x){
x[is.na(x) | x<0] <- min(na.omit(x[x>=0]))
return(x)
}
e <- mutate_each_(e, funs(na2min), names(e)[grepl("tot_intensity", names(e))]) %>%
mutate_("population density" = "TOTPOP"/"landarea")
str(e)
e <- mutate_each_(e, funs(na2min), names(e)[grepl("tot_intensity", names(e))]) %>%
mutate_("population density" = "TOTPOP"/"land_area")
?mutate_
names(e)
e <- mutate_each_(e, funs(na2min), names(e)[grepl("tot_intensity", names(e))]) %>%
mutate(population_density = TOTPOP/land_area)
e <- mutate_each_(e, funs(na2min), names(e)[grepl("tot_intensity", names(e))]) %>%
mutate(population_density = TOTPOP/land_area,
Income_Dollars = as.integer(as.character(sub(",", "", Income_Dollars))))
str(e)
runApp()
runApp()
input$groups
input$groups <- c("black", "Hispanic")
input$groups
na.omit(vars$group[vars$group!=""]
)
runApp()
str(d)
binwidth <- range(na.omit(d$x))
bindwidth <- (binwidth[2] - binwidth[1]) / 20
runApp()
?helperText
?textOutput
?helperText
runApp()
?h3
runApp()
runApp()
vars <- read.csv("data/variable_names", stringsAsFactors=F) %>%
filter(category != "other") %>%
arrange(desc(category), display)
vars
runApp()
runApp()
runApp()
runApp()
