ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
FIPS <- maps::county.fips # fips-to-name dictionary from maps library
e <- full_join(ds, dr) %>%
left_join(FIPS, .)
str(e)
map("county", regions=".", fill = TRUE, col=rep("black", length(na.omit(e$fips))),
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
map("county", regions=".", fill = TRUE, col=rep("black", length(na.omit(e$income_dollars))),
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
length(na.omit(e$income_dollars))
length(na.omit(e$Income_Dollars))
map("county", regions=".", fill = TRUE, col=rep("black", length(na.omit(e$Income_Dollars))),
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
runApp()
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
FIPS <- maps::county.fips # fips-to-name dictionary from maps library
e <- full_join(ds, dr) %>%
left_join(FIPS, .)
input <- list(xv=names(e)[grepl("Mino", names(e))][1],
yv=names(e)[grepl("tornado", names(e))][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
d <- data.frame(state_fips=e$state_fips,
county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,input$xv],
y=e[,input$yv]) %>%
mutate(xlog=log10(x), ylog=log10(y))
if(input$region != "USA") d <- filter(d, state %in% input$region)
# get 2D color values
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog"),
switch(input$yscale, "linear"="y", "log10"="ylog"))
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]))#, c("purple", "blue", "black", "red"))
d$color[is.na(d$color)] <- "gray95"
map("county", regions=region, fill = TRUE, col = d()$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
map("county", regions=".", fill = TRUE, col = d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
runApp()
runApp()
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
FIPS <- maps::county.fips # fips-to-name dictionary from maps library
str(ds)
ds$CTYNAME[ds$TOTPOP==max(na.omit(ds$TOTPOP))]
ds$CTYNAME[ds$TOTPOP==max(na.omit(ds$TOTPOP))]
max(na.omit(ds$TOTPOP))
ds$CTYNAME[ds$TOTPOP==max(na.omit(ds$TOTPOP))]
str(e)
filter(e, TOTPOP==max(TOTPOP, na.rm=T))
e <- full_join(ds, dr) %>%
left_join(FIPS, .)
filter(e, TOTPOP==max(TOTPOP, na.rm=T))
d <- data.frame(state_fips=e$state_fips,
county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,input$xv],
y=e[,input$yv]) %>%
mutate(xlog=log10(x), ylog=log10(y))
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog"),
switch(input$yscale, "linear"="y", "log10"="ylog"))
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]))#, c("purple", "blue", "black", "red"))
d$color[is.na(d$color)] <- "black"
runApp()
FIPS <- maps::county.fips
str(FIPS
)
e <- full_join(ds, dr) %>%
left_join(FIPS, .)
str(d)
d <- data.frame(fips=e$fips,
state_fips=e$state_fips,
county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,input$xv],
y=e[,input$yv]) %>%
mutate(xlog=log10(x), ylog=log10(y))
all.equal(d$fips, FIPS$fips)
runApp()
data(countyMapEnv)
data("countyMapEnv")
data(countyMapEnv)
countyMapEnv
map("county")
runApp()
library(devtools)
library(maps)
library(mapproj)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
if(!require(colormap)) install_github("matthewkling/colormap", "colormap") # Add the package colormap that Matt created because he's a bamf.
select <- dplyr::select
# load data
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
# fips-to-name dictionary from maps library;
# this is also the required plotting order for the maps library
FIPS <- maps::county.fips
e <- full_join(ds, dr) %>%
left_join(FIPS, .)
runApp()
runApp()
cty <- readRDS("counties.rds")
cty <- readRDS("data/counties.rds")
head(cty)
head(FIPS)
runApp()
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
str(cty)
tail(cty)
nrow(na.omit(cty))
str(cty)
e <- full_join(ds, dr)
str(e)
e <- full_join(ds, dr) %>%
left_join(cty, .)
str(e)
tail(e)
head(e)
input <- list(xv=names(e)[grepl("Mino", names(e))][1],
yv=names(e)[grepl("tornado", names(e))][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
d <- data.frame(fips=e$fips,
state_fips=e$state_fips,
county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,input$xv],
y=e[,input$yv]) %>%
mutate(xlog=log10(x), ylog=log10(y))
if(input$region != "USA") d <- filter(d, state %in% input$region)
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog"),
switch(input$yscale, "linear"="y", "log10"="ylog"))
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]))#, c("purple", "blue", "black", "red"))
d$color[is.na(d$color)] <- "black"
map("county", regions=region, fill=TRUE, col=d()$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
dev.off()
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
table(d$color)
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
e <- full_join(ds, dr)
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
e <- full_join(ds, dr, "fips")
str(ds)
str(ds)
str(dr)
all.equal(ds$fips, dr$fips)
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0))))
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips)
# fips-to-name dictionary from maps library;
FIPS <- maps::county.fips
# a clean counties table with the proper number and order of counties for plotting
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
e <- full_join(ds, dr) %>%
left_join(cty, .)
e <- full_join(ds, dr)
str(ds)
str(dr)
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips, -land_area)
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips)
# fips-to-name dictionary from maps library;
FIPS <- maps::county.fips
# a clean counties table with the proper number and order of counties for plotting
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
e <- full_join(ds, dr)
str(e)
str(r)
all.equal(dr$fips, ds$fips)
e <- cbind(dr, select(ds, -fips))
if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips)) %>%
left_join(cty, .)
runApp()
runApp()
str(e)
input <- list(xv=names(e)[grepl("Mino", names(e))][1],
yv=names(e)[grepl("tornado", names(e))][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
input
d <- data.frame(fips=e$fips,
state_fips=e$state_fips,
county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,input$xv],
y=e[,input$yv]) %>%
mutate(xlog=log10(x), ylog=log10(y))
runApp()
library(devtools)
library(maps)
library(mapproj)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
if(!require(colormap)) install_github("matthewkling/colormap", "colormap") # Add the package colormap that Matt created because he's a bamf.
select <- dplyr::select
# load data
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips, -land_area)
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-CTYNAME, -state_fips, -county_fips)
# fips-to-name dictionary from maps library;
FIPS <- maps::county.fips
# a clean counties table with the proper number and order of counties for plotting
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
#e <- full_join(ds, dr) %>%
#      left_join(cty, .)
if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips)) %>%
left_join(cty, .)
str(e)
runApp()
runApp()
s <- data.frame(e[,input$groups])
s <- as.data.frame(as.matrix(s) * e$TOTPOP)
if(ncol(s)==1) names(s) <- input$groups
v <- e[,input$envvar]
if(class(v)=="factor") v <- as.character(v)
v <- as.numeric(v)
g <- data.frame(state_fips=e$state_fips,
county_fips=e$county_fips,
state=as.character(e$STNAME)) %>%
cbind(v) %>%
cbind(s) %>%
gather(race, pop, -v, -state_fips, -county_fips, -state) %>%
group_by(race) %>%
mutate(prop_pop = pop / sum(na.omit(pop))) %>%
na.omit()
runApp()
input <- list(xv=names(e)[grepl("Mino", names(e))][1],
yv=names(e)[grepl("tornado", names(e))][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
map("county", regions=".", fill = TRUE, col=rep("black", nrow(cty)),
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
runApp()
str(e)
e[e$STNAME=="Idaho",]
str(e[e$STNAME=="Idaho",])
ds[ds$STNAME=="Idaho",]
str(ds)
str(dr)
dr[dr$STNAME=="Idaho",]
filter(dr, STNAME=="Idaho")
str(cty)
filter(cty, grepl("idaho", polyname))
filter(e, STNAME=="Idaho")
# load data
ds <- read.csv("data/cleanedsocial.csv", stringsAsFactors=F) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-STNAME, -CTYNAME, -state_fips, -county_fips, -land_area)
dr <- read.csv("data/cleanedrisk.csv", stringsAsFactors=F) %>%
select(-land_area) %>%
mutate(state_fips=as.integer(state_fips),
county_fips=as.integer(county_fips)) %>%
mutate(fips = as.integer(paste0(state_fips, str_pad(county_fips, 3, "left", 0)))) %>%
select(-CTYNAME, -state_fips, -county_fips)
# fips-to-name dictionary from maps library;
FIPS <- maps::county.fips
# a clean counties table with the proper number and order of counties for plotting
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
#e <- full_join(ds, dr) %>%
#      left_join(cty, .)
if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips)) %>%
left_join(cty, .)
filter(e, STNAME=="Idaho")
input <- list(xv=names(e)[grepl("Mino", names(e))][1],
yv=names(e)[grepl("tornado", names(e))][1],
xscale="linear",
yscale="linear",
smoother="none",
region="USA",
groups=names(e)[grepl("Perc", names(e), ignore.case=T)][1],
envvar=names(e)[grepl("tornado", names(e))][1],
scale="linear",
histogram_region="USA")
d <- data.frame(fips=e$fips,
#state_fips=e$state_fips,
#county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,input$xv],
y=e[,input$yv]) %>%
mutate(xlog=log10(x), ylog=log10(y))
if(input$region != "USA") d <- filter(d, state %in% input$region)
# get 2D color values
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog"),
switch(input$yscale, "linear"="y", "log10"="ylog"))
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]))#, c("purple", "blue", "black", "red"))
d$color[is.na(d$color)] <- "black"
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
d <- data.frame(fips=e$fips,
#state_fips=e$state_fips,
#county_fips=e$county_fips,
state=e$STNAME,
pop=e$TOTPOP,
x=e[,input$xv],
y=e[,input$yv]) %>%
mutate(xlog=log10(x), ylog=log10(y))
if(input$region != "USA") d <- filter(d, state %in% input$region)
filter(d, STNAME=="Idaho")
filter(d, state=="Idaho")
colvars <- c(switch(input$xscale, "linear"="x", "log10"="xlog"),
switch(input$yscale, "linear"="y", "log10"="ylog"))
goodrows <- apply(d[,colvars], 1, function(x) all(is.finite(x)))
d$color[goodrows] <- colors2d(na.omit(d[goodrows,colvars]))#, c("purple", "blue", "black", "red"))
d$color[is.na(d$color)] <- "black"
filter(d, state=="Idaho")
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
runApp()
percent_map <- function(var, color, legend.title, min = 0, max = 100) {
# generate vector of fill colors for map
shades <- colorRampPalette(c("white", color))(100)
# constrain gradient to percents that occur between min and max
var <- pmax(var, min)
var <- pmin(var, max)
percents <- as.integer(cut(var, 100,
include.lowest = TRUE, ordered = TRUE))
fills <- shades[percents]
# plot choropleth map
map("county", fill = TRUE, col = fills,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
# overlay state borders
map("state", col = "white", fill = FALSE, add = TRUE,
lty = 1, lwd = 1, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
# add a legend
inc <- (max - min) / 4
legend.text <- c(paste0(min, " % or less"),
paste0(min + inc, " %"),
paste0(min + 2 * inc, " %"),
paste0(min + 3 * inc, " %"),
paste0(max, " % or more"))
legend("bottomleft",
legend = legend.text,
fill = shades[c(1, 25, 50, 75, 100)],
title = legend.title)
}
map("county", regions=".", fill=TRUE, col=d$color,
resolution = 0, lty = 0, projection = "polyconic",
myborder = 0, mar = c(0,0,0,0))
cty <- readRDS("data/counties.rds")
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips)) %>%
left_join(cty, .)
View(e)
runApp()
if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips)) %>%
left_join(cty, .)
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
cty <- readRDS("data/counties.rds")
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
e <- cbind(dr, select(ds, -fips))
e <- cbind(dr, select(ds, -fips)) %>%
left_join(cty, .)
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
#e <- full_join(ds, dr) %>%
#      left_join(cty, .)
if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips))
e <- left_join(cty, e)
?left_join
cty <- readRDS("data/counties.rds") %>%
mutate(polyname = name) %>%
select(polyname) %>%
left_join(., FIPS)
#e <- full_join(ds, dr) %>%
#      left_join(cty, .)
if(!all.equal(ds$fips, dr$fips)) stop("social and risk data are misaligned")
e <- cbind(dr, select(ds, -fips))
e <- dplyr::left_join(cty, e)
nrow(cty)==nrow(e)
e <- cbind(dr, select(ds, -fips))
e <- dplyr::left_join(cty, e)
if(nrow(cty)!=nrow(e)) stop("incorrect county structure")
